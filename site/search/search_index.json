{"config":{"lang":["en"],"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Ruby on Rails Notes: Documenting notes for Ruby on Rails.","title":"Ruby on Rails Notes:"},{"location":"#ruby-on-rails-notes","text":"Documenting notes for Ruby on Rails.","title":"Ruby on Rails Notes:"},{"location":"rails/asset_pipeline_to_yarn_webpacker/","text":"Moving from asset pipeline to yarn/webpacker: https://samuelmullen.com/articles/replacing-the-rails-asset-pipeline-with-webpack-and-yarn/","title":"Moving from asset pipeline to yarn/webpacker:"},{"location":"rails/asset_pipeline_to_yarn_webpacker/#moving-from-asset-pipeline-to-yarnwebpacker","text":"https://samuelmullen.com/articles/replacing-the-rails-asset-pipeline-with-webpack-and-yarn/","title":"Moving from asset pipeline to yarn/webpacker:"},{"location":"rails/distinct_rails/","text":"Distinct in Rails: Mostly used with Select: Model.select(:rating).distinct If nothing is passed, id is used: [6] pry(main) User.all.distinct.count (2.3ms) SELECT COUNT(DISTINCT users . id ) FROM users = 165 While using with Pluck it uses the items in the pluck to make it distinct. User.distinct.pluck(:name).count (0.9ms) SELECT DISTINCT users . name FROM users = 165 User.distinct.pluck(:name, :shortname).count (0.9ms) SELECT DISTINCT users . name , users . shortname FROM users","title":"Distinct in Rails:"},{"location":"rails/distinct_rails/#distinct-in-rails","text":"","title":"Distinct in Rails:"},{"location":"rails/distinct_rails/#mostly-used-with-select","text":"Model.select(:rating).distinct","title":"Mostly used with Select:"},{"location":"rails/distinct_rails/#if-nothing-is-passed-id-is-used","text":"[6] pry(main) User.all.distinct.count (2.3ms) SELECT COUNT(DISTINCT users . id ) FROM users = 165","title":"If nothing is passed, id is used:"},{"location":"rails/distinct_rails/#while-using-with-pluck-it-uses-the-items-in-the-pluck-to-make-it-distinct","text":"User.distinct.pluck(:name).count (0.9ms) SELECT DISTINCT users . name FROM users = 165 User.distinct.pluck(:name, :shortname).count (0.9ms) SELECT DISTINCT users . name , users . shortname FROM users","title":"While using with Pluck it uses the items in the pluck to make it distinct."},{"location":"rails/readme/","text":"Notes for Rails","title":"Notes for Rails"},{"location":"rails/readme/#notes-for-rails","text":"","title":"Notes for Rails"},{"location":"rails/security/","text":"Ways to make Rails app more secure: ApplicationController class ApplicationController ActionController::Base protect_from_forgery with: :exception # Prevent CSRF attacks by raising an exception. APIs protect_from_forgery with: :null_session","title":"Ways to make Rails app more secure:"},{"location":"rails/security/#ways-to-make-rails-app-more-secure","text":"","title":"Ways to make Rails app more secure:"},{"location":"rails/security/#applicationcontroller","text":"class ApplicationController ActionController::Base protect_from_forgery with: :exception # Prevent CSRF attacks by raising an exception.","title":"ApplicationController"},{"location":"rails/security/#apis","text":"protect_from_forgery with: :null_session","title":"APIs"},{"location":"rails/session/","text":"Session on Rails: sessions allow users to authenticate once and remain signed in for future requests. Name of the cookie: Name of the cookie matches the key we set in session_store.rb Rails.application.config.session_store :cookie_store, key: '_my_website_session' Cookie on Browser: Name: '_my_website_session' content: '234asdf24234e' Domain: 'your_website.com' path: '/' Sample session object: ActiveRecord::SessionStore::Session.first ActiveRecord::SessionStore::Session Load (0.5ms) SELECT sessions .* FROM sessions ORDER BY sessions . id ASC LIMIT $1 [[ LIMIT , 1]] = # ActiveRecord::SessionStore::Session id: 1, session_id: d1223423423412352358 , data: 2423423422V4cGlyZXNfYXQ435435asdfHDIwMTYtMD35345AgMT... , created_at: 2016-03-30 14:50:41 , updated_at: 2016-03-30 14:50:41 In data ```ruby 2.6.3 :010 ActiveRecord::SessionStore::Session.first.data ActiveRecord::SessionStore::Session Load (0.5ms) SELECT \"sessions\".* FROM \"sessions\" ORDER BY \"sessions\".\"id\" ASC LIMIT $1 [[\"LIMIT\", 1]] = {\"expires_at\"= \"2020-03-30 15:50:41 UTC\"} ### Database table: ```ruby ActiveRecord::SessionStore::Session Cleaning up inactive sessions: db:sessions:trim","title":"Session on Rails:"},{"location":"rails/session/#session-on-rails","text":"sessions allow users to authenticate once and remain signed in for future requests.","title":"Session on Rails:"},{"location":"rails/session/#name-of-the-cookie","text":"Name of the cookie matches the key we set in session_store.rb Rails.application.config.session_store :cookie_store, key: '_my_website_session' Cookie on Browser: Name: '_my_website_session' content: '234asdf24234e' Domain: 'your_website.com' path: '/'","title":"Name of the cookie:"},{"location":"rails/session/#sample-session-object","text":"ActiveRecord::SessionStore::Session.first ActiveRecord::SessionStore::Session Load (0.5ms) SELECT sessions .* FROM sessions ORDER BY sessions . id ASC LIMIT $1 [[ LIMIT , 1]] = # ActiveRecord::SessionStore::Session id: 1, session_id: d1223423423412352358 , data: 2423423422V4cGlyZXNfYXQ435435asdfHDIwMTYtMD35345AgMT... , created_at: 2016-03-30 14:50:41 , updated_at: 2016-03-30 14:50:41 In data ```ruby 2.6.3 :010 ActiveRecord::SessionStore::Session.first.data ActiveRecord::SessionStore::Session Load (0.5ms) SELECT \"sessions\".* FROM \"sessions\" ORDER BY \"sessions\".\"id\" ASC LIMIT $1 [[\"LIMIT\", 1]] = {\"expires_at\"= \"2020-03-30 15:50:41 UTC\"} ### Database table: ```ruby ActiveRecord::SessionStore::Session","title":"Sample session object:"},{"location":"rails/session/#cleaning-up-inactive-sessions","text":"db:sessions:trim","title":"Cleaning up inactive sessions:"},{"location":"resources/books/","text":"Ruby Books: Ruby best Practices: https://www.benorenstein.com/blog/ruby-best-practices-a-review","title":"Ruby Books:"},{"location":"resources/books/#ruby-books","text":"","title":"Ruby Books:"},{"location":"resources/books/#ruby-best-practices","text":"https://www.benorenstein.com/blog/ruby-best-practices-a-review","title":"Ruby best Practices:"},{"location":"resources/conference/","text":"To watch: https://www.youtube.com/watch?v=I8m6rY4JI1U feature=emb_title","title":"Conference"},{"location":"resources/conference/#to-watch","text":"https://www.youtube.com/watch?v=I8m6rY4JI1U feature=emb_title","title":"To watch:"},{"location":"resources/ruby_resources/","text":"Ruby Resources: Great articles: https://www.rubyguides.com/ https://medium.com/@sologoubalex Good beginners guide: https://www.rubyguides.com/ruby-tutorial/ to read: https://www.rubyguides.com/2018/10/method-visibility/ https://www.rubyguides.com/2016/01/ruby-mutability/ https://www.rubyguides.com/2017/07/ruby-constants/#comments https://www.rubyguides.com/2018/11/dup-vs-clone/ https://medium.com/@tjoye20/ruby-access-control-basics-public-vs-private-vs-protected-methods-7788b26e04a7","title":"Ruby Resources:"},{"location":"resources/ruby_resources/#ruby-resources","text":"Great articles: https://www.rubyguides.com/ https://medium.com/@sologoubalex","title":"Ruby Resources:"},{"location":"resources/ruby_resources/#good-beginners-guide","text":"https://www.rubyguides.com/ruby-tutorial/ to read: https://www.rubyguides.com/2018/10/method-visibility/ https://www.rubyguides.com/2016/01/ruby-mutability/ https://www.rubyguides.com/2017/07/ruby-constants/#comments https://www.rubyguides.com/2018/11/dup-vs-clone/ https://medium.com/@tjoye20/ruby-access-control-basics-public-vs-private-vs-protected-methods-7788b26e04a7","title":"Good beginners guide:"},{"location":"resources/serverless/","text":"Serverless: Great intro: https://www.youtube.com/watch?v=Fx3ZGy-mbV4","title":"Serverless:"},{"location":"resources/serverless/#serverless","text":"Great intro: https://www.youtube.com/watch?v=Fx3ZGy-mbV4","title":"Serverless:"},{"location":"ruby/by_value_vs_by_reference/","text":"By Value or By Reference: Methods: In ruby, arguments inside a method are passed by reference In ruby, we have a different situation, the variable that we have inside the method stores a reference to an object. Thus, if we will change an object inside the method, then it will be changed also outside the method.","title":"By Value or By Reference:"},{"location":"ruby/by_value_vs_by_reference/#by-value-or-by-reference","text":"","title":"By Value or By Reference:"},{"location":"ruby/by_value_vs_by_reference/#methods","text":"In ruby, arguments inside a method are passed by reference In ruby, we have a different situation, the variable that we have inside the method stores a reference to an object. Thus, if we will change an object inside the method, then it will be changed also outside the method.","title":"Methods:"},{"location":"ruby/constants/","text":"Constants in Ruby: How to create constants? (kinda) FRUIT = orange Anything that starts with uppercase is a constant in Ruby. Array String Hash They are constants because the first letter is uppercase. Constants can changes... but you will get an warning: ABC = 1 ABC = 2 2: warning: already initialized constant ABC There is no way to prevent a constant from changing because variables in Ruby are not containers, they are simply pointers to objects. Or labels, if you prefer. A constant doesn\u2019t require any special symbol or syntax to declare. You just need to make the first letter an uppercase letter. The following are valid constants: ABC = 1 Goo = 2 Foo = 3 Notice that you can\u2019t define constants inside a method. When you define a class, what you\u2019re really doing is creating a Class object, which is assigned to a constant. The constant becomes the class name. no real constants in Ruby. Common Errors: puts Foo # uninitialized constant Foo (NameError)","title":"Constants in Ruby:"},{"location":"ruby/constants/#constants-in-ruby","text":"","title":"Constants in Ruby:"},{"location":"ruby/constants/#how-to-create-constants-kinda","text":"FRUIT = orange Anything that starts with uppercase is a constant in Ruby. Array String Hash They are constants because the first letter is uppercase. Constants can changes... but you will get an warning: ABC = 1 ABC = 2 2: warning: already initialized constant ABC There is no way to prevent a constant from changing because variables in Ruby are not containers, they are simply pointers to objects. Or labels, if you prefer. A constant doesn\u2019t require any special symbol or syntax to declare. You just need to make the first letter an uppercase letter. The following are valid constants: ABC = 1 Goo = 2 Foo = 3 Notice that you can\u2019t define constants inside a method. When you define a class, what you\u2019re really doing is creating a Class object, which is assigned to a constant. The constant becomes the class name. no real constants in Ruby.","title":"How to create constants? (kinda)"},{"location":"ruby/constants/#common-errors","text":"puts Foo # uninitialized constant Foo (NameError)","title":"Common Errors:"},{"location":"ruby/dup_vs_clone/","text":"Dup vs Clone in Ruby:","title":"Dup vs Clone in Ruby:"},{"location":"ruby/dup_vs_clone/#dup-vs-clone-in-ruby","text":"","title":"Dup vs Clone in Ruby:"},{"location":"ruby/get_set_ruby/","text":"Getter/Setter in Ruby? attr_accessor, atrr_reader and attr_writer: A Ruby object has its methods public by default, but its data is private. So if you need to access the data, for either reading or writing, you need to make it public somehow. Great article: https://mixandgo.com/learn/ruby_attr_accessor_attr_reader_attr_writer class Person def initialize(name) @name = name end # this is getter method equivalent in Java. # called attr_reader in ruby def name @name end end john = Person.new( John ) puts john.name # = John equivalent class Person attr_reader :name def initialize(name) @name = name end end john = Person.new( John ) puts john.name Setter: attr_writer Getter and Setter: attr_accessor Basically attr_accessor is a shortcut for when you need both attr_reader and attr_writer. It squashes down those two lines into one. Like so. class Person attr_reader :name, :age, :sex, :email attr_writer :name, :age, :sex, :email def initialize(name) @name = name end end to: class Person attr_accessor :name, :age, :sex, :email def initialize(name) @name = name end end Getter: There is nothing special about this, an attr_reader is a shortcut for writing an accessor method like this one: def author @author end","title":"Getter/Setter in Ruby? attr_accessor, atrr_reader and attr_writer:"},{"location":"ruby/get_set_ruby/#gettersetter-in-ruby-attr_accessor-atrr_reader-and-attr_writer","text":"A Ruby object has its methods public by default, but its data is private. So if you need to access the data, for either reading or writing, you need to make it public somehow. Great article: https://mixandgo.com/learn/ruby_attr_accessor_attr_reader_attr_writer class Person def initialize(name) @name = name end # this is getter method equivalent in Java. # called attr_reader in ruby def name @name end end john = Person.new( John ) puts john.name # = John equivalent class Person attr_reader :name def initialize(name) @name = name end end john = Person.new( John ) puts john.name","title":"Getter/Setter in Ruby? attr_accessor, atrr_reader and attr_writer:"},{"location":"ruby/get_set_ruby/#setter","text":"attr_writer","title":"Setter:"},{"location":"ruby/get_set_ruby/#getter-and-setter","text":"attr_accessor Basically attr_accessor is a shortcut for when you need both attr_reader and attr_writer. It squashes down those two lines into one. Like so. class Person attr_reader :name, :age, :sex, :email attr_writer :name, :age, :sex, :email def initialize(name) @name = name end end to: class Person attr_accessor :name, :age, :sex, :email def initialize(name) @name = name end end","title":"Getter and Setter:"},{"location":"ruby/get_set_ruby/#getter","text":"There is nothing special about this, an attr_reader is a shortcut for writing an accessor method like this one: def author @author end","title":"Getter:"},{"location":"ruby/instance_vs_class/","text":"Instance vs Class: Method Instance vs Class : Variable","title":"Instance vs Class: Method"},{"location":"ruby/instance_vs_class/#instance-vs-class-method","text":"","title":"Instance vs Class: Method"},{"location":"ruby/instance_vs_class/#instance-vs-class-variable","text":"","title":"Instance vs Class : Variable"},{"location":"ruby/loops/","text":"Loops in Ruby: Each: numbers.each { |n| puts n } Each with a hash: hash = { bacon: 300, coconut: 200 } hash.each { |key,value| puts #{key} price is #{value} } Each with index: animals = [ cat , dog , tiger ] animals.each_with_index { |animal, idx| puts We have a #{animal} with index #{idx} } Times: 10.times { |i| puts hello #{i} } Range (1..10).each { |i| puts i } While: n = 0 while n 10 puts n n += 1 end Stop a Loop? break","title":"Loops in Ruby:"},{"location":"ruby/loops/#loops-in-ruby","text":"","title":"Loops in Ruby:"},{"location":"ruby/loops/#each","text":"numbers.each { |n| puts n }","title":"Each:"},{"location":"ruby/loops/#each-with-a-hash","text":"hash = { bacon: 300, coconut: 200 } hash.each { |key,value| puts #{key} price is #{value} }","title":"Each with a hash:"},{"location":"ruby/loops/#each-with-index","text":"animals = [ cat , dog , tiger ] animals.each_with_index { |animal, idx| puts We have a #{animal} with index #{idx} }","title":"Each with index:"},{"location":"ruby/loops/#times","text":"10.times { |i| puts hello #{i} }","title":"Times:"},{"location":"ruby/loops/#range","text":"(1..10).each { |i| puts i }","title":"Range"},{"location":"ruby/loops/#while","text":"n = 0 while n 10 puts n n += 1 end","title":"While:"},{"location":"ruby/loops/#stop-a-loop","text":"break","title":"Stop a Loop?"},{"location":"ruby/method_visibility/","text":"Method visibility in Ruby: There is really no private methods in Ruby. Because it Ruby provides a way to access private methods.","title":"Method visibility in Ruby:"},{"location":"ruby/method_visibility/#method-visibility-in-ruby","text":"There is really no private methods in Ruby. Because it Ruby provides a way to access private methods.","title":"Method visibility in Ruby:"},{"location":"ruby/params_ruby/","text":"Params Ruby: Different types of parameter in Ruby: 1. Positional Params def sum(salary, bonus, tax) salary + bonus - tax end sum(100, 10, 30) # = 80 2. Keyword Param Introduced at Ruby 2.0. Keyword arguments allow us to switch the order of the arguments, without affecting the behavior of the method. Also known as named parameters, keyword arguments, required keyword arguments. def sum(salary:, bonus:, tax:) salary + bonus - tax end sum(salary: 100, bonus: 10, tax: 30) # = 80 Passing default value: def sum(salary:, bonus: 10, tax:) salary + bonus - tax end sum(salary: 100, tax: 30) # = 80 3. Variable Aruments: def print_all(**args) print args end print_all(1, 2, 3) # = The **x is the same as variable arguments, but for keyword arguments. It will be a hash instead of an array. Catch-all Argument: def print_all(*) end This means that the method is accepting any arguments, but it\u2019s not doing anything with them. It\u2019s similar to using the underscore character (_) inside a block to show which arguments you aren\u2019t using. Order required - optional - variable - keyword def testing(a, b = 1, *c, d: 1, **x) p a,b,c,d,x end testing('a', 'b', 'c', 'd', 'e', d: 2, x: 1) Benefits of Keyword params: Order doesn't matter If order chagges on the method parameter, argument doesn't have to change on all the places where it's called. Usually, the code clarity and maintainability gained from keyword arguments outweigh the terseness offered by positional arguments. Parameter vs Arguments: Argument: - The entity that we can pass to the method during the call is called an argument. Parameter: - The entity that we declare when we define a method is called a parameter. When we pass arguments to a method, the method creates a local variable which has the same name In ruby, arguments inside a method are passed by reference Interesting Facts: 1. Parentheses for paramters are optional: def method_name a,b,c puts a,b,c,d end method_name 0,1,2 But it's recommended for redeability.","title":"Params Ruby:"},{"location":"ruby/params_ruby/#params-ruby","text":"","title":"Params Ruby:"},{"location":"ruby/params_ruby/#different-types-of-parameter-in-ruby","text":"","title":"Different types of parameter in Ruby:"},{"location":"ruby/params_ruby/#1-positional-params","text":"def sum(salary, bonus, tax) salary + bonus - tax end sum(100, 10, 30) # = 80","title":"1. Positional Params"},{"location":"ruby/params_ruby/#2-keyword-param","text":"Introduced at Ruby 2.0. Keyword arguments allow us to switch the order of the arguments, without affecting the behavior of the method. Also known as named parameters, keyword arguments, required keyword arguments. def sum(salary:, bonus:, tax:) salary + bonus - tax end sum(salary: 100, bonus: 10, tax: 30) # = 80","title":"2. Keyword Param"},{"location":"ruby/params_ruby/#passing-default-value","text":"def sum(salary:, bonus: 10, tax:) salary + bonus - tax end sum(salary: 100, tax: 30) # = 80","title":"Passing default value:"},{"location":"ruby/params_ruby/#3-variable-aruments","text":"def print_all(**args) print args end print_all(1, 2, 3) # = The **x is the same as variable arguments, but for keyword arguments. It will be a hash instead of an array. Catch-all Argument: def print_all(*) end This means that the method is accepting any arguments, but it\u2019s not doing anything with them. It\u2019s similar to using the underscore character (_) inside a block to show which arguments you aren\u2019t using.","title":"3. Variable Aruments:"},{"location":"ruby/params_ruby/#order","text":"required - optional - variable - keyword def testing(a, b = 1, *c, d: 1, **x) p a,b,c,d,x end testing('a', 'b', 'c', 'd', 'e', d: 2, x: 1)","title":"Order"},{"location":"ruby/params_ruby/#benefits-of-keyword-params","text":"Order doesn't matter If order chagges on the method parameter, argument doesn't have to change on all the places where it's called. Usually, the code clarity and maintainability gained from keyword arguments outweigh the terseness offered by positional arguments.","title":"Benefits of Keyword params:"},{"location":"ruby/params_ruby/#parameter-vs-arguments","text":"Argument: - The entity that we can pass to the method during the call is called an argument. Parameter: - The entity that we declare when we define a method is called a parameter. When we pass arguments to a method, the method creates a local variable which has the same name In ruby, arguments inside a method are passed by reference","title":"Parameter vs Arguments:"},{"location":"ruby/params_ruby/#interesting-facts","text":"","title":"Interesting Facts:"},{"location":"ruby/params_ruby/#1-parentheses-for-paramters-are-optional","text":"def method_name a,b,c puts a,b,c,d end method_name 0,1,2 But it's recommended for redeability.","title":"1. Parentheses for paramters are optional:"},{"location":"ruby/rails_vs_ruby_methods/","text":"Rails vs Ruby methods: I have wasted some times thinking the Rails method was available on Ruby, because I was working on Rails pry session. empty? - Ruby https://apidock.com/ruby/Array/empty%3F blank? - Rails https://apidock.com/rails/Object/blank%3F","title":"Rails vs Ruby methods:"},{"location":"ruby/rails_vs_ruby_methods/#rails-vs-ruby-methods","text":"I have wasted some times thinking the Rails method was available on Ruby, because I was working on Rails pry session.","title":"Rails vs Ruby methods:"},{"location":"ruby/rails_vs_ruby_methods/#empty-ruby","text":"https://apidock.com/ruby/Array/empty%3F","title":"empty? -&gt; Ruby"},{"location":"ruby/rails_vs_ruby_methods/#blank-rails","text":"https://apidock.com/rails/Object/blank%3F","title":"blank? -&gt; Rails"},{"location":"ruby/readme/","text":"Notes for Ruby:","title":"Notes for Ruby:"},{"location":"ruby/readme/#notes-for-ruby","text":"","title":"Notes for Ruby:"},{"location":"ruby/variables/","text":"Variables in Ruby: global variable ($apple) instance variable (@apple) = To store shared data that all the methods(in the same class) can use. class variable (@@apple) constant (APPLE)","title":"Variables in Ruby:"},{"location":"ruby/variables/#variables-in-ruby","text":"global variable ($apple) instance variable (@apple) = To store shared data that all the methods(in the same class) can use. class variable (@@apple) constant (APPLE)","title":"Variables in Ruby:"},{"location":"ruby_version_manager/readme/","text":"Ruby Version Manager: Change the version that you want to use: If you want to 2.6.3 rvm use 2.6.3 To make a ruby version default: rvm use --default 2.6.3 Check which ruby is being used: rvm which ruby","title":"Ruby Version Manager:"},{"location":"ruby_version_manager/readme/#ruby-version-manager","text":"","title":"Ruby Version Manager:"},{"location":"ruby_version_manager/readme/#change-the-version-that-you-want-to-use","text":"If you want to 2.6.3 rvm use 2.6.3","title":"Change the version that you want to use:"},{"location":"ruby_version_manager/readme/#to-make-a-ruby-version-default","text":"rvm use --default 2.6.3","title":"To make a ruby version default:"},{"location":"ruby_version_manager/readme/#check-which-ruby-is-being-used","text":"rvm which ruby","title":"Check which ruby is being used:"}]}